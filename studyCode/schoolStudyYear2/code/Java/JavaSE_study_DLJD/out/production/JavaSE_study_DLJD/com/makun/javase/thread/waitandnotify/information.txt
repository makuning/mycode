/*
1.4、关于object类中的wait和notify方法。( 生产者和消费者模式! )
    第一: wait和notify方法不是线程对象的方法，是java 中任何一- 个java对象
        都有的方法，因为这两个方式是object类中自带的。
        wait方法和notify方法不是通过线程对象调用,
        不是这样的: t.wait(), 也不是这样的: t.notify() . .不对。

    第二: wait() 方法作用?
        Object。= new Object() ;
        o. wait() ;
        表示:
        让正在o对象.上活动的线程进入等待状态，无期限等待,
        直到被唤醒为止。
        o.wait() ;方法的调用，会让“当前线程(正在o对象上
        活动的线程)"进入等待状态。.

    第三: notify() 方法作用?
        object。= new qlpject() ;
        o. notify() ;
        表示:
        唤醒正在o对象.上等待的线程。
        还有一一个notifyA1l ()方法:
        这个方法是唤醒o对象_上处于等待的所有线程。


T线程在o对象上活动。
T线程是当前线程对象。
当调用o.wait(方法之后。
T线程进入无期限等待。
当前线程进入等待状态。

直到最终调用o.notify(方法。
o.notify(方法的调用可以让正在
o对象上等待的线程唤醒。

*/


/*
1、使用wait方法和notify方法实现“生产者和消费者模式”
2、什么是“生产者和消费者模式”?
    生产线程负责生产,消费线程负责消费。
    生产线程和消费线程要达到均衡。
    这是-种特殊的业务需求,在这种特殊的情况下需要使用wait方法和notify方法。
3、wait和notify方法不是线程对象的方法,是普通java对象都有的方法。
4、wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作-一个仓库。 有线程安全问题。
5、wait方法作用:o. wait()让正在o对象.上活动的线程t进入等待状态,并且释放掉t线程之前占有的o对象的锁。
6、notify方法作用:o.notify()让正在o对象上等待的线程唤醒,只是通知,不会释放o对象上之前占有的锁。
7、模拟这样一个需求:
    仓库我们采用list集合。.
    List集合中假设只能存储1个元素。
    1个元素就表示仓库满了。
    如果List.集合中元素个数是e ,就表示仓库空了。
    保证List集合中永远都是最多存储1个元素。
    必须做到这种效果:生产1个消费1个。

*/


/*
作业：
1、使用生产者和消费者模式实现，交替输出:
假设只有两个线程，输出以下结果:
    t1-->1
    t2-->2
    t1-->3
    t2-->4
    t1-->5
    t2-->6
    要求:必须交替，并且t1线程负贲输出奇数。t2线程负贲输出偶数。
    两价线程共享一个数字，每个线程执行时都要对这个数字进行: ++
        public class Num {
            inti;
        }

        synchronized (num) {
            if (num是奇数) {
                nun. wait() ;
            }

            // 输出偶数
            // notifyAll ()
        }

        synchronized (num) {
            if (nun是偶数) {
                num. wait() ;
            }

            // 输出奇数
            // notifyA1l() ;
        }
*/