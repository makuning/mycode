*************************** 线程的学习 ********************************

/*
4、多线程
    4.1、什么是进程?什么是线程?
        进程是一个应用程序(1个进程是一个软件)。
        线程是一个进程中的执行场景/执行单元。
        一个进程可以启动多个线程。

    4.2、对于java程序来说，当在DOS命令 窗口中输入:
        java HelloWorld 回车之后。
        会先启动JVM，而JVM就是一个进程。
        JVM再启动一个主线程调用main方法。
        同时再启动一个垃圾回收线程负贲看护，回收垃圾。
        最起码，现在的java程序中至少有两个线程并发，
        一个是垃圾回收线程，一个是执行main方法的主线程。

    4.3、进程和线程是什么关系?举个例子
        阿里巴巴:进程
            马云:阿里巴巴的一个线程
            童文红:阿里巴巴的-一个线程

        京东:进程
            强东:京东的一一个线程
            妹妹:京东的一个 线程

        进程可以看做是现实生活当中的公司。
        线程可以看做是公司当中的某个员工。

        注意:
            进程A和进程B的内存独立不共享。( 阿里巴巴和京东资源不会共享的! )
            线程A和线程B呢?
            在java语言中:
                线程A和线程B,堆内存和方法区内存共享。.
                但是栈内存独立，一个 线程一一个站。

        假设启动10个线程，会有10个栈空间，每个栈和每个栈之间,
        互不干扰，各自执行各自的，这就是多线程并发。

    4.4、思考一个问题:
        使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束。
        main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在
        压栈弹栈。

    4.5、分析一一个问题:对于单核的CPU来说，真的可以做到真正的多线程并发吗?
        什么是真正的多线程并发?

            对于多核的CPU电脑来说，真正的多线程并发是没问题的。
            4核CPU表示同一一个时间点上，可以真正的有4个进程并发执行。

        t1线程执行t1的。
        t2线程执行t2的。
        t1不会影响t2，t2也不会影响t1。这叫做真正的多线程并发。
        单核的CPU表示只有-一个大脑:|
            不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉。
            对于单核的CPU来说，在某--个时间点上实际上只能处理一件事情，但是由于
            CPU的处理速度极快，多个线程之间频繁切换执行，跟人来的感觉是:多个事情
            同时在做!!!!!

                线程A:播放音乐
                线程B:运行魔兽游戏
                线程A和线程B频繁切换执行，人 类会感觉音乐一直在播放，游戏一直在运行,
                给我们的感觉是同时并发的。


            电影院采用胶卷播放电影，--个胶卷-一个胶卷播放速度达到--定程度之后,
            人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像
            一根钢针扎到手上，到最终感觉到疼，这个过程是需要"很长的”时间的，在
            这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。

*/

/*
5、java语言中，实现线程有两种方式，那两种方式呢?
    java支持多线程机制。并且java已经将多线程实现了，我们只需要继承就行了。
    第一种方式:编写-一个类，直接继承java. lang. Thread,重写run方法。



public class ThreadTest02 {
    public static void main(String[] args) {
        // 这里是main方法,这里的代码属于主线程，在主栈中运行。
        // 新建一个分支线程对象
        MyThread myThread = new MyThread();

        //启动线程
        myThread.run();     //不会启动线程,不会分配新的分支栈。
        // start()方法的作用是:启动一个分支线程，在JVM中开辟-一个新的栈空间 ,这段代码任务完成之后,瞬间就结束了。
        // 这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来, start()方法就结束了。线程就启动成功了。
        // 启动成功的线程会自动调用run方法,并且run方法在分支栈的栈底部(压栈)。
        // run方法在分支栈的栈底部, main方法在主栈的栈底部。run 和main是平级的。
        // myThread. start();   // 这个才能启动线程

        // 这里的代码还是运行在主线程中。
        for(int i = 0; i < 1000; i++){
        System. out . println("主线程--->”+ i);
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        // 编写程序,这段程序运行在分支线程中(分支栈)。
        for(int i = 0; i < 1000; i++){
            System. out . println("分支线程--->" + i);
        }
    }
}


*/

/*
实现线程的第一种方式:
    编写一个类,直接继承java. lang. Thread ,重导run方法。
    怎么创建线程对象? new就行了。
    怎么启动线程呢?调用线程对象的start()方法。

注意:
亘古不变的道理:
    方法体当中的代码永远都是自上而下的顺序依次逐行执行的。
以下程序的输出结果有这样的特点:
有先有后。
有多有少。
这是咋回事?这里画一个问号???????????????????????

*/

/*
    第一种方式:编写一个类，直接继承java. lang . Thread,重写run方法。
        //定义线程类
        public class MyThread extends Thread{
            public void run() {

            }
        }

        //创建线程对象
        MyThread t = new MyThread() ;

        //启动线程。
        t. start() ;

    第二种方式:编写-一个类，实现java. lang . Runnable接口，实现run方 法。
        //定义一个可运行的类
        public class MyRunnable implements Runnable {
            public void run() {

            }
        }

        //创建线程对象
        Thread t = new Thread (new MyRunnable() ) ;

        //启动线程
        t. start() ;

    注意:第二种方式实现接口比较常用，因为-一个类实现了接口，它还可以去继承其它的类，更灵活。



    /*
    实现线程的第二种方式，編写-个类实现java. lang. Runnable接口。
    */
    public class ThreadTest03 {
        public static void main(String[] args) {
            //创建一个可运行的对象
            MyRunnable r = new MyRunnable();

            //将可运行的对象封装成- - -个线程对象
            Thread t = new Thread(r);

            //启动线程`
            t.start();
        }
    }


    //这并不是一个线程类，是一个可运行的类。它还不是一个线程。
    class MyRunnable implements Runnable {
        @Override
        public void run() {

        }
    }

*/


/*

/*
    采用匿名内部类可以吗?
*/
public class ThreadTest04 {
    public static void main(String[] args) {
    //创建线程对象,采用匿名内部类方式。
    Thread t = new Thread(new Runnable(){
        @Override
        public void run() {
            for(int i = 0; i < 100; i++){
                System. out . println("分支线程---> " + i);
            }
        }
     });

    //启动线程
    t.start();
    }
}

*/




/*
6、
关于线程对象的生命周期?
    新建状态
    就绪状态
    运行状态
    阻塞状态
    死亡状态
*/

/*
    1、怎么获取当前线程对象?
        Thread t = Thread. currentThread();
        返回值t就是当前线程。
    2、获取线程对象的名字
    String name =线程对象. getName();
    3、修改线程对象的名字
        线程对象. setName("线程名字");
    4、当线程没有设置名字的时候，默认的名字有什么规律? (了解一下)
        Thread-0
        Thread-1
        Thread-2
        Thread-3


public static void main(String[] args) {
    //currentThread就是当前线程对象
    //这个代码出现在main方法当中,所以当前线程就是主线程。
    Thread currentThread = Thread. current Thread( );

    //创建线程对象
    MyThread2 t = new MyThread2();

    //设置线程的名字
    t. setName("t1");

    //获取线程的名字
    String tName = t.getName();
    System. out. println(tName); //Thread-0
    MyThread2 t2 = new MyThread2();
    t2. setName("t2");
    System. out . println(t2. getName()); //Thread-1

    //启动线程
    t.start();
}

*/


/*
关于线程的sleep方法:
    static void sleep(long millis)
    1、静态方法: Thread. sleep(1000);
    2、参数是毫秒
    3、作用:让当前线程进入休眠，进入“阻塞状态”,放弃占有CPU时间片，让给其它线程使用。
        这行代码出现在A线程中, A线程就会进入休眠。
        这行代码出现在B线程中, B线程就会进入休眠。
    4、Thread.sleep()方法 ，可以做到这种效果:
        间隔特定的时间，去执行-段特定的代码，每隔多久执行一次。

*/

/*
sleep睡眠太久了，如果希望半道上醒来，你应该怎么办?也就是说怎么叫醒-个正在睡眠的线程? ?
    注意:这个不是终断线程的执行,是终止线程的睡眠。

    //终断t 线程的睡眠(这种终断睡眠的方式依靠了java的异常处理机制。)
    t. interrupt(); //干忧，一盆冷水过去 !

*/

/*
在java中怎么强行终止一个线程的执行。
    t.stop(); //已过时(不建议使用。)

    这种方式存在很大的缺点:容易丢失数据。因为这种方式是直接将线程杀死了，
    线程没有保存的数据将会丢失。不建议使用。


怎么合理的终止-一个线程的执行。这种方式是很常用的。
    //终止线程
    //你想要什么时候终止t的执行,那么你把标记修改为false ,就结束了。
    r.run = false;




class MyRunable4 implements Runnable {
    //打一个布尔标计
    boolean run = true;

    @Override
    public void run() {
        for(inti=0;i<10;i++){
            if(run){
                System. out . println(Thread . current Thread() . getName() +“--->” + i);
                try {
                    Thread. sleep( millis: 1000);
                } catch (InterruptedException e) {
                    e. printStackTrace();
                }
            } else {
                // return就结束了,你在结束之前还有什么没保存的。
                // 在这里可以保存呀。
                // save....
                // 终止当前线程

                // 终止当前线程
                return;
            }
        }
    }
}
*/

/*
1、(这部分内容属于了解)关于线程的调度
    1.1、常见的线程调度模型有哪些?
        抢占式调度模型:
            那个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。
            java采用的就是抢占式调度模型。

        均分式调度模型:
            平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。
            平均分配，一切平等。
            有一- 些编程语言，线程调度模型采用的是这种方式。

    1.2、java中提供了哪些方法是和线程调度有关系的呢?
    实例方法:
    void setPriority (int newPriority) 设置线程的优先级
    int getPriority() 获取线程优先级
        最低优先级1
        默认优先级是5
        最高优先级10
    优先级比较高的获取CPU时间片可能会多- -些。(但 也不完全是，大概率是多的。)

    静态方法:
    static void yield()让位方法
    暂停当前正在执行的线程对象，并执行其他线程
    yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。
    yield()方法的执行会让当前线程从“运行状态”回到就绪状态”。
    注意:在回到就绪之后，有可能还会再次抢到。

    实例方法:
    void join ()
    合并线程
    class MyThread1 extends Thread {
        public void doSome () {
            MyThread2 t = new MyThread2 () ;
            t.join(); // 当前线程进入阻塞，t线程执行，直到t线程结束。当前线程才可以执行
        }
    }

    class MyThread2 extends Thread{
    }

    //优先级较高的,只是抢到的CPU时间片相对多-些。
    //大概率方向更偏向于优先级比较高的。

*/

/*
2、关于多线程并发环境下，数据的安全问题。
    2.1、 为什么这个是重点?
        以后在开发中，我们的项目都是运行在服务器当中,
        而服务器已经将线程的定义，线程对象的创建，线程
        的启动等，都已经实现完了。这些代码我们都不需要
        编写。

        最重要的是:你要知道，你编写的程序需要放到一一个
        多线程的环境下运行，你更需要关注的是这些数据
        在多线程并发的环境下是否是安全的。(重点:***** )

    2.2、什么时候数据在多线程并发的环境下会存在安全问题呢?
        三个条件:
        条件1:多线程并发。
        条件2:有共享数据。
        条件3:共享数据有修改的行为。，
        满足以上3个条件之后，就会存在线程安全问题。

    2.3、怎么解决线程安全问题呢?
        当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在
        线程安全问题，怎么解决这个问题?
            线程排队执行。(不 能并发)。
            用排队执行解决线程安全问题。
            这种机制被称为:线程同步机制。
            专业术语叫做:线程同步，实际上就是线程不能并发了，线程必须排队执行。
        怎么解决线程安全问题呀?
            使用、线程同步机制"。
            线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全
            第一位，只有数据安全了，我们才可以谈效率。数据不安全，没有效率的事儿。

    2.4、说到线程同步这块，涉及到这两个专业术语:
        异步编程模型:
            线程t1和线程t2,各自执行各自的，t1不管t2, t2不管t1,
            谁也不需要等谁，这种编程模型叫做:异步编程模型。
            其实就是:多线程并发(效率较高。)
            异步就是并发。

        同步编程模型:
            线程t1和线程t2,在线程t1执行的时候，必须等待t2线程执行
            结束，或者说在t2线程执行的时候，必须等待t1线程执行结束,
            两个线程之间发生了等待关系，这就是同步编程模型。
            效率较低。线程排队执行。
            同步就是排队。

*/

/*
//以下这几行代码必须是线程排队的，不能并发。
//一个线程把这里的代码全部执行结束之后，另一个线程才能进来。

线程同步机制的语法是:
    synchronized(){
        //线程同步代码块。
    }

synchronized后面小括号中传的这个“数据是相当关键的。
这个数据必须是多线程共享的数据。才能达到多线程排队。

()中写什么?
    那要看你想让哪些线程同步。
        假设t1、t2、t3、t4、t5，有5个线程，
        你只希望t1 t2 t3排队, t4 t5不需要排队。怎么办?
            你一定要在()中写一个t1 t2 t3共享的对象。 而这个
            对象对于t4 t5来说不是共享的。

这里的共享对象是:账户对象。
账户对象是共享的，那么this就是账户对象吧! ! !
不一定是this ,这里只要是多线程共享的那个对象就行。

synchronized(this){
    double before = this . getBalance( );
    double after = before - money;

    try {
        Thread. sleep( millis: 1000) ;
    } catch (InterruptedException e) {
        e. printStackTrace();
    }

    this. setBalance(after);
}
*/


/*
在java语言中,任何一个对象都有“-把锁”,其实这把锁就是标记。( 只是把它叫做锁。)
100个对象，100把锁。1个对象1把锁。.
以下代码的执行原理?
    1、假设t1 和t2线程并发,开始执行以下代码的时候,肯定有一个先一个后。

    2、假设t1 先执行了,遇到了synchronized ,这个时候自动找“后面共享对象”的对象锁,
        找到之后，并占有这把锁,然后执行同步代码块中的程序，在程序执行过程中-直都是
        占有这把锁的。直到同步代码块代码结束,这把锁才会释放。

    3、假设t1 已经占有这把锁,此时t2也遇到synchronized关键字，也会去占有后面
        共享对象的这把锁,结果这把锁被t1占有, t2只能在同步代码块外面等待t1的结束，
        直到t1把同步代码块执行结束了, t1会归还这把锁,此时2终于等到这把锁,然后
        t2占有这把锁之后,进入同步代码块执行程序。

        这样就达到了线程排队执行。
        这里需要注意的是:这个共享对象一定要选好了。这个共享对象-定是你需要排队
        执行的这些线程对象所共享的。

*/


/*
synchronized (this){
//synchronized (obj) {
//synchronized ("abc") { // "abc ”在字符串常量池当中。
//synchronized (null) { //报错:空指针。
//synchronized (obj2) { //这样编写就不安全了。因为obj2 不是共享对象。

    double before = this . getBalance();
    double after = before - money ;

    try {
        Thread. sleep( millis: 1000);
    } catch (InterruptedException e) {
        e. printStackTrace();
    }

    this. setBalance(after);
}

3、Java中有三大变量?
    实例变量:在堆中。
    静态变量:在方法区。
    局部变量:在栈中。
    以上三大变量中:

    局部变量永远都不会存在线程安全问题。
        因为局都变量不共享。(一个线程一个栈。>
        局部变量在栈中。所以局部变量永远都不会共享。
        实例变量在维中,维只有1个。

    静态变量在方法区中,方法区只有1个.
    堆和方法区都是多线程共享的，所以可能存在线程安全问题。
    堆和方法区都是多线程共享的，所以可能存在线程安全问题。

    局部变量+常量:不会有线程安全问题。
    成员变量:可能会有线程安全问题。

*/


/*
同步代码块越小效率越高。


    /*
    在实例方法上可以使用synchronized吗?可以的。
        synchronized出现在实例方法上，一定锁的是this。
        没得挑。只能是this。 不能是其他的对象了。
        所以这种方式不灵活。

        另外还有一一个缺点: synchronized出现在实例方法上，
        表示整个方法体都需要同步，可能会无故扩大同步的
        范围，导致程序的执行效率降低。所以这种方式不常用。

        synchronized使用在实例方法上有什么优点?
            代码写的少了。节俭了。

        如果共享的对象就是this ,并且需要同步的代码块是整个方法体,
        建议使用这种方式。.
    */
public synchronized void withdraw( double money){
    double before = this. getBalance(); // 10000
    double after = before - money;

    try {
        Thread. sleep( millis: 1000) ;
    } catch (InterruptedException e) {
        e. printStackTrace();
    }

    this. setBalance(after);
}

*/


/*
4、如果使用局部变量的话:
    建议使用: stringBuilder.
    因为局部变量不存在线程安全问题。选择stringBuilder.
    stringBuffer效宰比较低。

    ArrayList是非线程安全的。
    Vector是线程安全的。
    HashMap HashSet是非线程安全的。
    Hashtable是线程安全的。


5、总结:
    synchronized有三种写法:
        第一种:同步代码块
            灵活
            synchronized (线程共享对象) {
                同步代码块;
            }

        第二种:在实例方法上使用synchronized
            表示共享对象一定是this
            并且同步代码块是整个方法体。

        第三种:在静态方法上使用synchronized
            表示找类锁。
            类锁永远只有1把。
            就算创建了100个对象，那类锁也只有一把。
            对象锁: 1个对象1把锁，100个 对象100把锁。
            类锁:100个对象，也可能只是1把类锁。

*/


/*
死锁代码要会写。
-般面试官要求你会写。
只有会写的，会在以后的开发中注意这个事儿。
因为死锁很难调试。

synchronized在开发中最好不要嵌套使用。
-不小心就可能会导致死锁现象的发生。

*/


/*
6、聊一-聊，我们以后开发中应该怎么解决线程安全问题?
    是一上来就选择线程同步吗? synchronized
    不是，synchronized会让程序的执行效率降低，用户体验不好。
    系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择
    线程同步机制。
    第--种方案:尽量使用局部变量代替"实例变量和静态变量"。
    第二种方案:如果必须是实例变量，那么可以考虑创建多个对象，这样
    实例变量的内存就不共享了。(- 一个线程对应1个对象，100个 线程对应100个对象,
    对象不共享，就没有数据安全问题了。)
    第三种方案:如果不能使用局部变量，对象也不能创建多个，这个时候
    就只能选择synchronized了。线程同步机制。

7、线程这块还有那些内容呢?列举一下
    7.1、 守护线程
    7.2、 定时器
    7.3、 实现线程的第三三种方式: FutureTask方式， 实现Cal1able接口。 ( JDK8新特性。)
    7.4、 关于object类中的wai t和notify方法。 (生产者和消费者模式! )

*/


/*
1.1、守护线程，
    java语言中线程分为两大类:
        一类是:用户线程
        一-类是:守护线程( 后台线程)
    其中具有代表性的就是:垃圾回收线程(守护线程)。

    守护线程的特点:
        一般守护线程是一-个死循环，所有的用户线程只要结束,
        守护线程自动结束。
        注意:主线程main方法是一一个用户线程。.
        守护线程用在什么地方呢?

            每天00:00的时候系统数据自动备份。
            这个需要使用到定时器，并且我们可以将定时器设置为守护线程。
            一直在那里看着，没到00:00的时候就备份一次。所有的用户线程
            如果结束了，守护线程自动退出，没有必要进行数据备份了。


//启动线程之前,将线程设置为守护线程
t. setDaemon(true) ;
*/


/*
1.2、定时器
    定时器的作用:
        间隔特定的时间，执行特定的程序。
        每周要进行银行账户的总账操作。每天要进行数据的备份操作。
        在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现:

            可以使用sleep方法，睡眠，设置睡眠时间，没到这个时间点醒来，执行任务。这种方式是最原始的定时器。(比较low)

            在java的类库中已经写好了一个定时器: java.util.Timer，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。
            在实际的开发中，目前使用较多的是spring框架中提供的springTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务。

*/


/*

1.3、实现线程的第三种方式:实现Callable接口。( JDK8新特性。)
    这种方式实现的线程可以获取线程的返回值。
    之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void.

    思考:
    系统委派一个线程去执行-一个任务，该线程执行完任务之后，可能
    会有一一个执行结果，我们怎么能拿到这个执行结果呢?
    使用第三种方式:实现Callable接口方式。



//第一步:创建一个“未来任务类”对象。
//参数非常重要， 需要给-个Callable接口实现类对象。
FutureTask task = new FutureTask(new Callable() {
    @Override
    public Object call() throws Exception { // call()方法就相当于run方法。 只不过这个有返回值
        // 线程执行一个任务,执行之后可能会有-一个执行结果
        // 模拟执行
        System. out. println("ca11 method begin");
        Thread.sleep( millis: 1000 * 10);
        System. out. println("ca11 method end!");
        int a = 100;
        int b = 200;
        return a + b; //自动装箱( 3θ0结果变成Integer)
    }
});

//创建线程对象
Thread t = new Thread(task);

//启动线程
t. start();

//这里是main方法,这是在主线程中。
//在主线程中,怎么获取t线程的返回结果?
// get()方法的执行会导致“当前线程阻塞”
object obj = task.get();
System. out . println("线程执行结果:" + obj);

// main方法这里的程序要想执行必须等待get()方法的结束
//而get()方法可能需要很久。因为get()方法是为 了拿另一个线程的执行结果
//另一个线程执行是需要时间的。
System. out. println("he11o world!");


这种方式的优点:可以获取到线程的执行结果。
这种方式的缺点:效率比较低，在获取t线程执行结果的时候,当前线程受阻塞,效率较低。

*/


/*
1.4、关于object类中的wait和notify方法。( 生产者和消费者模式! )
    第一: wait和notify方法不是线程对象的方法，是java 中任何一- 个java对象
        都有的方法，因为这两个方式是object类中自带的。
        wait方法和notify方法不是通过线程对象调用,
        不是这样的: t.wait(), 也不是这样的: t.notify() . .不对。

    第二: wait() 方法作用?
        Object。= new Object() ;
        o. wait() ;
        表示:
        让正在o对象.上活动的线程进入等待状态，无期限等待,
        直到被唤醒为止。
        o.wait() ;方法的调用，会让“当前线程(正在o对象上
        活动的线程)"进入等待状态。.

    第三: notify() 方法作用?
        object。= new qlpject() ;
        o. notify() ;
        表示:
        唤醒正在o对象.上等待的线程。
        还有一一个notifyA1l ()方法:
        这个方法是唤醒o对象_上处于等待的所有线程。


T线程在o对象上活动。
T线程是当前线程对象。
当调用o.wait(方法之后。
T线程进入无期限等待。
当前线程进入等待状态。

直到最终调用o.notify(方法。
o.notify(方法的调用可以让正在
o对象上等待的线程唤醒。

*/


/*
1、使用wait方法和notify方法实现“生产者和消费者模式”
2、什么是“生产者和消费者模式”?
    生产线程负责生产,消费线程负责消费。
    生产线程和消费线程要达到均衡。
    这是-种特殊的业务需求,在这种特殊的情况下需要使用wait方法和notify方法。
3、wait和notify方法不是线程对象的方法,是普通java对象都有的方法。
4、wait方法和notify方法建立在线程同步的基础之上。因为多线程要同时操作-一个仓库。 有线程安全问题。
5、wait方法作用:o. wait()让正在o对象.上活动的线程t进入等待状态,并且释放掉t线程之前占有的o对象的锁。
6、notify方法作用:o.notify()让正在o对象上等待的线程唤醒,只是通知,不会释放o对象上之前占有的锁。
7、模拟这样一个需求:
    仓库我们采用list集合。.
    List集合中假设只能存储1个元素。
    1个元素就表示仓库满了。
    如果List.集合中元素个数是e ,就表示仓库空了。
    保证List集合中永远都是最多存储1个元素。
    必须做到这种效果:生产1个消费1个。

*/


/*
作业：
1、使用生产者和消费者模式实现，交替输出:
假设只有两个线程，输出以下结果:
    t1-->1
    t2-->2
    t1-->3
    t2-->4
    t1-->5
    t2-->6
    要求:必须交替，并且t1线程负贲输出奇数。t2线程负贲输出偶数。
    两价线程共享一个数字，每个线程执行时都要对这个数字进行: ++
        public class Num {
            inti;
        }

        synchronized (num) {
            if (num是奇数) {
                nun. wait() ;
            }

            // 输出偶数
            // notifyAll ()
        }

        synchronized (num) {
            if (nun是偶数) {
                num. wait() ;
            }

            // 输出奇数
            // notifyA1l() ;
        }
*/