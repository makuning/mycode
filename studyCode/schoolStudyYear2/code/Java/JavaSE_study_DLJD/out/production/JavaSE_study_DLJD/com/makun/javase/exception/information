异常

// 异常机制的作用？
    Java每次报错的内容就是Java自己写的异常处理
    程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常
    Java语言比较完善，提供了异常处理的方式（健壮性）
    程序出现错误，Java将异常信息打印到控制台输出，以供程序员阅读（打印的错误信息是JVM虚拟机打印的）
    我们自己也可以自己写异常处理

// Java语言中异常是以什么形式存在的？
    异常是以类的形式存在的，在java.lang包下
    每一个异常都可以创建异常对象

    在JVM编译的时候，如果编译出现错误，它会new一个对应的异常对象

    // 通过 “异常类” 实例化 “异常方法”
    NumberFormatException nfe = new NumberFormatException("数字格式化异常！");


// 理解异常类举例
    火灾（异常类）
        2003年2月2日：小明家着火了    （这就是一个异常对象）
        2020年12月2日：小胡家着火了   （这就是一个异常对象）

// UML （统一建模语言）
    // 所有的 错误 和 异常 都是可抛出的
    Object -（子类）-> Throwable（可抛出的） -（子类）-> Error（错误）、Exception（异常）

    // 所有的错误一旦发生，Java程序只有一个结果，就是退出程序，错误是无法处理的
    Error -（子类）-> VirtualMachineError（虚拟机错误）、IOError（输入输出错误）

    // 虚拟机错误的子类
    VirtualMachineError（虚拟机错误） -（子类）-> stackOverflowError（栈溢出错误）

    // 异常是可以处理的
    // 所有的ExceptionSubClass（Exception的直接子类）都是编译时异常
    /*
        编译时异常：
        不是在编译时发生的
        编译时异常指的是在编写程序阶段，必须预先对这种异常进行处理，如果不处理，编译器报错

        运行时异常：
        在编译程序阶段，可以选择处理，也可以选择不处理

        编译阶段异常是不会发生的
        因为编译时异常必须在编译（编写）阶段预先处理，如果不处理编译器要报错，因此得名
        所有的异常都是运行时发生的，因为只有运行的时候才能new对象
    */
    Exception -（子类）-> RuntimeException（运行时异常）、ExceptionSubClass（Exception的直接子类）

    // 运行时异常的子类
    RuntimeException（运行时异常） -（子类）-> NullPointerException（空的引用异常）、 ClassCastException（类转换异常） 、IllegalArgumentException（非法数据异常）

    // 非法数据异常的子类
    IllegalArgumentException（非法数据异常） -（子类）-> NumberFormatException（数字格式化异常）



    // 编译时异常和运行时异常的区别？？
    /*
        编译时异常一般发生的概率比较高。
            举例：
                看到外面下雨
                出门之前会预料到，如果不打伞，可能会生病（生病是一种异常）
                而且这个异常概率很高，所以出门需要拿一把伞
                “拿一把伞” 就是对 “生病异常“ 发生之前的一种处理方式

        运行时异常一般发生的概率比较低。
            举例：
                小明走在大街上，可能会被天上的飞机轮子砸到。
                被飞机轮子砸到也是一种异常，但是这种发生的概率比较低。
                在出门之前（程序运行阶段），没有必要提前对这种异常进行预处理。
                如果预处理这种异常，将活得很累

        假设Java中没有对异常进行划分，没有分为：编译时异常和运行时异常
        所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果？
            如果这样的话，程序是绝对安全的，但是程序员编写代码太累，代码到处都是处理异常的代码

        编译时异常又被称为 受检异常 和 受控异常
        运行时异常又被称为 非受检异常（未检异常） 和 非受控异常
    */

    // Java语言中对异常的处理包括两种方式
    第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级
        谁调用我，我就抛给谁，抛给上一级
    第二种方式：使用try..catch语句进行异常的捕捉
        这件事发生了，谁也不知道，因为我给抓住了

        举个例子：
            我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，”损失1000元“ 这可以看作时一个异常发生了，
            我有两种处理方式，
            第一种：我把这件事告诉我的领导。【异常上抛】
            第二种：我自己掏腰包把这个钱补上。【异常的捕捉】

    异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式

    Java中异常发生之后如果一直向上抛，最终抛给了main方法，main方法继续向上抛，
    抛给了调用者JVM，JVM知道这个异常后，只有一个结果，就是终止Java程序的执行



    异常处理方式：
        第一种：throws（上抛给调用者，推卸责任）
            ：关键字，表示上抛给调用者

        第二种：try .. catch进行捕捉（异常真正的解决了）
            try {
                // try尝试
            } catch (FileNotFoundException e) {
                /*
                异常，必须加一个变量名，这个变量的类型是FileNotFoundException，
                e变量中装的是一个内存地址，是new出来的异常对象的内存地址
                */
                // catch是捕捉异常之后走的分支
                // 出错后执行的代码
            } catch (异常2) {

            } catch (异常3) {

            } catch (异常1 | 异常2 | 异常3 e) {       // JDK8的新特性
            }
            // 分支捕获的异常应该从小到大


    用上抛的方式，出异常后，异常后的代码不会执行（一旦上报，当前方法就结束）
        需要上报用上抛（想让调用者知道）
    用捕捉的方式，出异常后，try中异常后的代码不会执行， 但是会进入相应的分支，并且会执行 try..catch 后的代码
        不需要上报就捕捉

    throw new 异常构造方法;   // 抛出一个异常



    异常对象的方法（所有的异常对象都有这两个方法）
        getMessage()                    // 获取异常简单的描述信息（返回一个字符串）
        printStackTrace()               // 打印异常追踪的堆栈信息（无返回值），采用的异步线程的方式打印的


    try {
        可能出错的代码;
    } catch (异常 e) {
        e.printStackTrace();    // 打印异常追踪信息（好习惯）
    }

    try..catch 中的finally子句
    在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常
    必须和try一起出现，不能单独编写
    try {

    } catch () {

    } finally {
        程序出没出错都一定要执行的代码，例如：流的关闭
    }

    只有System.exit()能治finally


    final finally finalize 有什么区别？
        final是一个关键字，表示最终的，不变的
        finally也是一个关键字，与try联合使用，在finally语句块中的代码是一定会执行的
        finalize()是Object类中的一个方法，作为方法名出现。所以finalize是标识符，这个方法由垃圾回收机制GC负责调用


    // 自定义异常
        SUN公司提供的JDK内置的异常是不够的，在实际开发中有很多异常，JDK中都是没有的
        Java中如何自定义异常？
            第一步：编写一个类继承Exception或者RuntimeException
            第二步：提供两个构造方法，一个无参数的，一个有参数的。


    // 重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少（运行时异常可以随便抛）