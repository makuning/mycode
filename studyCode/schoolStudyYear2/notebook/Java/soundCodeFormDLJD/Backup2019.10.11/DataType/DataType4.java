/*
  关于Java语言种的整数型
  byte、short、int、long
*/
public class DataType4{
	public static void main(String[] args){
		
		//100L是long类型字面值
		//x是long类变量
		//不存在类型转换，直接赋值
		long x=100L;
		
		//x是long类型，占用8个字节
		//y是int类型，占用4个字节
		//试试以下程序编译通过吗？
	    /*
		int y=x;
		编译报错（注意是编译就报错了，语法就不对！），出现错误
		错误: 不兼容的类型: 从long转换到int可能会有损失
		大容量不能直接赋值给小容量。
		*/
		
		//大容量转换成小容量，需要进行强制类型转换
		//强制类型转换需要加上“强制类型转换符”
		//加上强制类型转换符后编译通过了，但是运行阶段可能会损失精度。
		//注意：强制类型转换谨慎使用，因为精度损失的可能会非常严重！
		
		int y=(int)x;
		System.out.println(y);
		//这个程序没有精度损失，因为数字是100L。
		
		/*
		强制类型转换原理（拿100L举例）：
		
		原始数据：00000000  00000000 00000000 00000000 00000000 00000000 00000000 01100100
		解释一下，1100100是二进制下的100L，前面的0是符号位，long类型有8个字节
		强转之后的数据：00000000 00000000 00000000 01100100
		解释一下：这个数据就是正常的int类型下的100，有4个字节。
		原理：将左边的二进制砍掉【所有的数据强转都是这样完成的】
		*/
		
		//看几个强转之后损失精度的例子
		
		
		long k=2147483648L;
		int e=(int)k;
		System.out.println(e);
		//原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
		//强转后的数据：10000000 00000000 00000000 00000000（这是一个补码）
		//10000000 00000000 00000000 00000000此数据目前以补码形式存储在计算机内（都是补码形式）
		//将补码转换成原码就是最终值。
		//损失精度非常严重，会输出一个负数：-2147483648。
		
		//分析以下程序编译是否通过
		byte b=50;
		//50是int类型字面值，b是byte类型变量，大容量到小容量要强制类型转换，否则会编译报错。
		//但是实际编译通过了。
		
		byte c=127;
		
		//sun公司的一种特殊语法机制。
		//只要字面值没超过byte类型取值范围的，直接赋值，不需要加强转符了。
		//对byte的特殊优待？
		//那么其他的数据类型请到DataType5这个文件中看
		
		//byte b1=128;这个程序报错，超出byte取值范围。
		//进行强制类型转换
		byte b1=(byte)128;
		System.out.println(b1);
		//这一定会损失精度。
		//输出一个负数：-128。
		//原始数据：00000000 00000000 00000000 10000000
		//强转之后的数据：10000000【这是一个补码，它的原码是什么？】
		//是-128。
		
		//关于补码、反码和原码
		//这个得自己看了。。。
		
		
		//自己搞的几行代码分析是否编译报错
		/*
		int m1=2147483647;
		int m2=2147483648; 报错
		long m3=2147483648; 报错
		long m4=2147483648L;
		long m5=2147483647;小容量转大容量，自动类型转换
		随时测试以上代码
		*/
		
		//另外我自己总结的小知识点
		
		/*
		long m5=(long)2147483647;
		System.out.println(m5);
		上述代码自动类型转换，但我加了强制类型转换符，输出结果是正确的。
		*/
		
		
		
		
	}
}